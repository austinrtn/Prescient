## Overview
Entity Pools are semantically defined organizational structures for entities and their component data.  They are responsible for storing, managing, and manipulating any and all component data within the Prescient Engine.  Using Zig's compile-time capabilities, Entity Pools generate unique internal infrastructure determined by the pools user defined configuration, such as what component data is allowed to be stored in a pool, which component data entities from a pool are required to have, and the storage strategy pools use to store their data.  

## Why Entity Pools? 
Generally, other ECS engines take a much more uniform approach to how entities and their component data get stored in memory, iterated in systems, and accessed by queries.  This uniform approach means NPCs, UI elements, sound effects, world decorations, and every other category of entity gets stored together and managed in memory the same way, despite these categories being significantly different in numerous ways.  Entity Pools do not just provide a method to separate entities by category, they are a means to partition the entity data itself.  This fundamental shift in how entity data gets managed leads to a whole host of befits: configurable storage strategies for different categories of entities, less overhead dedicated to querying, better cache locality, and stronger compile-time type safety.  

# What Entity Pools Enable
- **[[Storage Strategy|Hybrid Storage Strategies]]**:  Some categories of entities benefit from different storage optimizations. For example, particle systems with thousands of short-lived entities benefit from Sparse-Set storage for fast creation/destruction, while player characters with stable component sets benefit from Archetype storage for cache-optimized iteration. This enables a whole dimension of optimization potential unique to Prescient and is by far its greatest optimization.

- **[[Query Mapping]]**: Because each pool has compile-time knowledge of its components, queries can skip entire pools that don't contain the queried components. Traditional ECS implementations must check every archetype at runtime. Prescient queries only examine pools that could possibly match, reducing query overhead.

- **Improved Cache Locality**:  Using Entity Pools to partition similar entity-component data by category of entity allows for better cache locality.  Entities of the same category are more likely to be queried by the same queries, and  iterated by the same systems.  Other ECS engines that store entity-component data in global data structures have entities with similar component makeups scattered throughout memory

- **Compile-Time Type Safety**: Users can choose which components entities can have within an Entity Pool and which components entities are required to have. This means developers can be specific about which entities can/must have which components, and these restrictions are enforced at compile-time instead of runtime.  

- **Clear Mental Model**:   

# Creating New Entity Pools
New entity pools can be added to the top of [[1.02 - Pool Registry|Pool Registry]].  Pools must be made public in order to be registered correctly.  Prescient's build system will automatically update the registry once it is added to the file underneath the [[general pool]] which is the "default" pool in Prescient.  Developers can configure the pool by passing a [[1.01 - PoolConfig|PoolConfig]] struct as the Entity Pool's parameter.

>[!example]
>```zig
>const EntityPool = @import("EntityPool.zig").EntityPoolType;
>const PoolConfig = @import("PoolConfig.zig").PoolConfig;
>
>//The preconfigured GeneralPool 
>pub const GeneralPool = EntityPool(PoolConfig{
>	.name = .GeneralPool,
>	.components = generalComponents,
>	.storage_strategy = .sparse,
>});
>
>//User added pool
>pub const ParticlePool = EntityPool(.{
>	.name = .ParticlePool,
>	.components = &.{
>		.Velocity,
>		.Color
>	},
>	.req = &.{.Posistion,},
>	.storage_strategy = .sparse,
>});
>```




>[!Example]
>To change a pool's storage strategy,  
> ```zig
> // ./ecs/registries/Pools.zig
> pub const UIElementsPool = EntityPool(.{
> 	.Components = &.{
> 		.Position, 
> 		.Dimension 
> 	}},
> 	.StorageStat = .Sparse
> });
> 
> ```
