# Overview
New [[1.00 - Entity Pools|Entity Pools]] can be added to the top of [[1.b - Pool Registry|Pool Registry]].  Pools must be made public in order to be registered correctly.  Prescient's build system will automatically update the registry once it is added to the file underneath the [[general pool]] which is the "default" pool in Prescient.  Developers can configure the pool by passing a [[1.a - PoolConfig|PoolConfig]] struct as the Entity Pool's parameter.

>[!example]
>```zig
>const EntityPool = @import("EntityPool.zig").EntityPoolType;
>const PoolConfig = @import("PoolConfig.zig").PoolConfig;
>
>//The preconfigured GeneralPool 
>pub const GeneralPool = EntityPool(PoolConfig{
>	.name = .GeneralPool,
>	.components = general_components,
>	.storage_strategy = .sparse,
>});
>
>//User added pool
>pub const ParticlePool = EntityPool(.{
>	.name = .ParticlePool,
>	.components = &.{
>		.Velocity,
>		.Color
>	},
>	.req = &.{.Posistion,},
>	.storage_strategy = .sparse,
>});
>```

# Good Pool Design 
Before creating a brand new pool, it's important to understand how to design Entity Pools in ways maximize performance and developer experience.  Poor pool design can actually hinder performance.  Creating optimal pools can be summarized by three fundamental aspects: how Pools get defined, how they are used at runtime, and how they are configured.

## Defining Pool Boundaries
How the developer defines the boundaries of Entity Pools is key to making the most out of them.  There are many ways one can determine how pool boundaries get defined: "entity type" (player, mobs, particles, items, decor), by system (movement, combat, rotating, targeting), or by game state (main menu, level 1, level 2, pause menu). While having a hypothetical variety of choices in constructing Entity Pools would seem beneficial, there is only one way to truly capitalize one the Entity Pool's approach to organizing both component data and our own mental models.  

