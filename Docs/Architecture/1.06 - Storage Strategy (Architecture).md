
# Archetype Storage:
An archetype in an ECS context is a data structure that contains a *struct of arrays* for component data, for each unique component composition that exists within an instance of the engine.  

> [!example] Archetype Example
> Here is a representation of a storage structure within an Entity Pool containing components of `Position`, `Velocity`, and `mass`.   Entity data composed of Position + Velocity will be stored in its corresponding archetype and separate from Entity-component data.  
> ```zig
> // Archetype of Position + Velocity
> const archetype1 = ComponentStorage{
> 	entities: {ent3, ent4, ent2,},
> 	Positions: {
> 		{.x = 0, .y = 0}, {.x = 4, .y = 2}, {.x = 12, .y = 6}
> 	},
> 	Velocity: {
> 		{.dx = 25, .dy = 2}, {.dx = 54, .dy = 9}, {.dx = 8, .dy = 2}
> 	},
> }
>
//Archetype of Position + Mass
const archetype2 = ComponentStorage{
> 	entities: {ent1, ent3},
> 	Positions: {
> 		{.x = 6, .y = 7}, {.x = 1, .y = 1},
> 	},
> 	Mass: {
> 		{.value = 10}, {.value = 3},
> 	},
> }
> ```

### Density and Cache Locality
Archetype storage is *dense*, which means it is tightly packed in memory (no null values in between elements)  This allows for maximum cache locality improving performance for systems where component data is frequently iterated.

### The Trade-off
Due to component data existing in their own archetypes, adding and removing components becomes computationally expensive because all of an entity's data must be copied from their source archetype to the archetype that corresponds with their new component compisition. 

# Sparse-Set Storage
A sparse-set is a data structure that uses a *sparse* array to map entity indices to their corresponding storage locations in *dense* arrays.  The sparse array acts as a lookup table, while the dense arrays hold the actual entity and component data contiguously.

> [!example] Sparse-Set Example
> Here is a representation of a sparse-set storage structure within an Entity Pool containing components of `Position`, `Velocity`, and `Mass`.  Unlike archetype storage, all entities exist within the same storage arrays regardless of their component composition.
> ```zig
> // Sparse Array - maps entity index to storage index
> // Entity indices:    0     1     2     3     4     5
> const sparse =     { null, 2,    0,    1,    null, 3  };
>
> // Dense Arrays - store actual data
> const entities =   { ent2, ent3, ent1, ent5 };
> const Positions =  {
> 	{.x = 12, .y = 6}, {.x = 0, .y = 0}, {.x = 4, .y = 2}, {.x = 6, .y = 7}
> };
> const Velocity =   {
> 	{.dx = 8, .dy = 2}, null, {.dx = 25, .dy = 2}, {.dx = 3, .dy = 1}
> };
> const Mass =       {
> 	null, {.value = 10}, null, {.value = 5}
> };
> ```
> In this example, `ent2` is at storage index 0 and has Position + Velocity.  `ent3` is at storage index 1 and has Position + Mass.  The sparse array allows direct lookup: to find `ent1`'s data, check `sparse[1]` which gives storage index 2.

### Flexibility
Sparse-set storage allows entities to add and remove components without moving their data.  When a component is added, the value is simply written to the entity's existing storage index.  When a component is removed, the value is set to null.  This makes structural changes to entities computationally cheap compared to archetype storage.

### The Trade-off
The sparse array introduces an extra layer of indirection when accessing entity data.  Additionally, component arrays may contain null values (for entities that don't have that component), resulting in less dense memory layout.  This makes iteration less cache-friendly compared to archetype storage where all entities in an archetype are guaranteed to have the same components packed tightly together.

>[!info] Parallel Component Arrays
>Both storage strategies utilize *parallel* component arrays, meaning entity of `element 0` in the entities array corresponds with all  data contained within `element 0` of all component arrays within the storage structure.  To better understand this, here is a table representing the archetype1 in the archetype example:
>
>   Component Array | Indx 0  |Indx 1|Indx 2|
>   | --- | --- | --- | ---  |
> Entity | Ent 3   |   Ent 4  |   Ent 2  |
> Position (x, y) |  0, 0  | 4, 2    |   12, 6  |
> Velocity (dx, dy) |   25, 2  |52,  9 | 8, 2 |

