# The Context 
ECS engines generally offer one type of entity storage: Archetype ***OR*** Sparse Set.  Archetype storage enables fast iteration speeds via cache optimization, but adding and removing components are computationally expensive operations.  With sparse set storage, adding and removing components is trivial, but is inherently cache hostile.  The limitation of a single storage strategy often forces developers to choose between development limitations or performance limitations, and other game engines are aware of this.  Bevy, for instance, recommends using entirely different libraries for managing particles because of the inherent rigidity of archetype based entity storage.  EnTT's pure sparse-set approach sacrifices iteration speeds for fast component migration.  Prescient's hybrid approach lets developers leverage both strategies, matching storage to usage patterns rather than accepting one-size-fits-all constraints.

# The Decision
Taking advantage of Zig's compile time capabilities allows developers to choose their individual storage types at the Entity Pool level.  While defining an Entity Pool, the developer can choose their storage strategy, and the pool will generate specific code for its storage type at compile time.  Queries can also handle different storage types by generating the proper code for each pool at compile time as well.  If a query finds two pools that match, one pool being sparse set and the other being archetype, it will generate specific code for each pool and handle them individually. This means different pools with different storage types never conflict, archetype storage keeps 100% of it's performance, and sparse set keeps 100% of its flexibility.

# The Trade-Offs
The main-trade off is the added learning curve to Prescient.  This is mitigated by prioritizing functional explanations of the trade offs between the two rather than the architectural differences, and by making sure that any entity storage configuration is opt-in rather than forced upon the user.  Other than that, there are no other considerable trade offs.  Performance and flexibility remains the same for both strategies, and the API stays uniform thanks to Zig's compile-time capabilities.

# Why Comptime? 
