## Overview
Entity Pools are semantically defined organizational structures for entities and their component data.  They are responsible for storing, managing, and manipulating any and all component data within the Prescient Engine.  Using Zig's compile-time capabilities, Entity Pools generate unique internal infrastructure determined by the pools user defined configuration, such as what component data is allowed to be stored in a pool, which component data entities from a pool are required to have, and the storage strategy pools use to store their data.  

## Why Entity Pools? 
Generally, other ECS engines take a much more uniform approach to how entities and their component data get stored in memory, iterated in systems, and accessed by queries.  This uniform approach means NPCs, UI elements, sound effects, world decorations, and every other category of entity gets stored together and managed in memory the same way, despite these categories being significantly different in numerous ways.  Entity Pools do not just provide a method to separate entities by category, they are a means to partition entity data in memory.  This fundamental shift in how entity data gets managed leads to a whole host of befits: configurable storage strategies for different categories of entities, less overhead dedicated to querying, better cache locality, and stronger compile-time type safety.  

# Creating New Entity Pools
New entity pools can be added to the top of [[1.02 - Pool Registry|Pool Registry]].  Pools must be made public in order to be registered correctly.  Prescient's build system will automatically complete the registry for entity pool entries.  `EntityPool` takes a [[1.01 - Pool Configuration|PoolConfig]] struct as an argument.  Here is what the Pool Registry would look like with an added Particle Pool.

>[!Examlpe]
>```zig
>const EntityPool = @import("EntityPool.zig").EntityPoolType;
>const PoolConfig = @import("PoolConfig.zig").PoolConfig;
>
>//The preconfigured GeneralPool 
>pub const GeneralPool = EntityPool(PoolConfig{
>	.name = .GeneralPool,
>	.components = generalComponents,
>	.req = null,
>	.storage_strategy = .sparse,
>});
>
>//User added pool
>pub const ParticlePool = EntityPool(.{
>	.name = .ParticlePool,
>	.components = &.{
>		.Velocity,
>		.color
>	},
>	.req = &.{.Posistion,},
>	.storage_strategy = .sparse,
>});
>```





##### components:
>A slice of `ComponentRegistry.componentNames` values.  
>The `componentNames` values in the slice determine which components entities are allowed to have.  All entity pools must include this argument in their declaration.
##### req:
>A slice of `ComponentRegistry.componentNames` values.  
>The componentName values in the slice determine which components are required to have upon creation.  Attempting to create entities without all of the components within a pool's `req` argument, or trying to remove those same components will result in compile time errors.

##### storage_strategy:


# Advantages of Entity Pools
##### <u>Hybrid Storage Strategies</u>
The most significant performance benefit of Entity Pools is their configurable storage strategy.  Other ECS engines have to decide between storage types: archetype or sparse-set. Archetype storage is proficient for enabling systems to iterate over many entities, but performance degrades when entities are destroyed often, there are frequent changes in their component makeup.  Sparse-set storage is the opposite: poor iteration speed, but destroying entities and adding / removing components from entities is trivial.   Archetype storage is best suited for entity types that are iterated over often and have relatively stable component makeups, such as mobs, projectiles, and terrain chunks.  

>[!Example]
>To change a pool's storage strategy,  
> ```zig
> // ./ecs/registries/Pools.zig
> pub const UIElementsPool = EntityPool(.{
> 	.Components = &.{
> 		.Position, 
> 		.Dimension 
> 	}},
> 	.StorageStat = .Sparse
> });
> 
> ```


##### <u>afds</u>
Entity pools provide another degree of cache locality by partitioning different categories of entities in memory.  Instead of all variations of all types of all entities being stored within the same global structure in memory, pools partition the entities they store 